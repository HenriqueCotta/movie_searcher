lib
├── data
│   ├── models
│   │   ├── >>> movie_dto.dart <<<
│   │   └── >>> user_dto.dart <<<
│   ├── repositories
│   │   ├── >>> movies_repository.dart <<<
│   │   └── >>> user_repository.dart <<<
│   └── services
│       ├── >>> dio_service.dart <<<
│       ├── >>> local_store_service.dart <<<
│       └── >>> movie_service.dart <<<
├── >>> di.dart <<<
├── domain
│   ├── models
│   │   └── >>> movie.dart <<<
│   └── usecases (ignored)
├── >>> main.dart <<<
├── ui
│   ├── core
│   │   ├── layout
│   │   │   └── >>> breakpoints_rules.dart <<<
│   │   ├── theme
│   │   │   ├── >>> app_theme.dart <<<
│   │   │   ├── >>> palette.dart <<<
│   │   │   ├── >>> theme_cubit.dart <<<
│   │   │   └── >>> typography.dart <<<
│   │   └── widgets
│   │       └── >>> theme_toggle_action.dart <<<
│   └── movies
│       ├── view_models
│       │   ├── detail
│       │   │   ├── >>> detail_cubit.dart <<<
│       │   │   └── >>> detail_state.dart <<<
│       │   ├── recent
│       │   │   ├── >>> recent_cubit.dart <<<
│       │   │   └── >>> recent_state.dart <<<
│       │   └── search
│       │       ├── >>> search_bloc.dart <<<
│       │       ├── >>> search_event.dart <<<
│       │       └── >>> search_state.dart <<<
│       ├── views
│       │   ├── >>> detail_page.dart <<<
│       │   ├── >>> recent_page.dart <<<
│       │   └── >>> search_page.dart <<<
│       └── widgets
│           ├── >>> movie_card.dart <<<
│           ├── >>> movie_grid_title.dart <<<
│           └── search_page
│               ├── >>> result_sliver.dart <<<
│               ├── search_bar
│               │   └── >>> search_bar_area.dart <<<
│               └── >>> states_sliver.dart <<<
└── utils (ignored)



--- di.dart:START ---
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:movie_searcher/data/repositories/movies_repository.dart';
import 'package:movie_searcher/data/services/dio_service.dart';
import 'package:movie_searcher/data/services/local_store_service.dart';
import 'package:movie_searcher/data/services/movie_service.dart';
import 'package:movie_searcher/ui/core/theme/app_theme.dart';
import 'package:movie_searcher/ui/core/theme/theme_cubit.dart';
import 'package:movie_searcher/ui/movies/view_models/detail/detail_cubit.dart';
import 'package:movie_searcher/ui/movies/view_models/recent/recent_cubit.dart';
import 'package:movie_searcher/ui/movies/view_models/search/search_bloc.dart';
import 'package:movie_searcher/ui/movies/views/detail_page.dart';
import 'package:movie_searcher/ui/movies/views/recent_page.dart';
import 'package:movie_searcher/ui/movies/views/search_page.dart';

Widget buildApp() {
  const baseUrl = String.fromEnvironment('OMDB_BASE_URL', defaultValue: 'https://www.omdbapi.com/');
  const apiKey = String.fromEnvironment('OMDB_API_KEY', defaultValue: 'SUA_CHAVE');

  final dio = DioService(baseUrl);
  final movieSvc = MovieService(dio, apiKey: apiKey);
  final localStore = LocalStoreService();
  final moviesRepo = MoviesRepository(movieSvc);

  return MultiRepositoryProvider(
    providers: [
      RepositoryProvider.value(value: moviesRepo),
      RepositoryProvider.value(value: localStore),
    ],
    child: BlocProvider(
      create: (_) => ThemeCubit()..load(),
      child: Builder(
        builder: (context) {
          final mode = context.watch<ThemeCubit>().state;
          return MaterialApp(
            title: 'Movies',
            debugShowCheckedModeBanner: false,
            theme: buildLightTheme(),
            darkTheme: buildDarkTheme(),
            themeMode: mode,
            initialRoute: '/',
            routes: {
              '/': (ctx) => BlocProvider(
                create: (_) => SearchBloc(ctx.read<MoviesRepository>()),
                child: const SearchPage(),
              ),
              '/detail': (ctx) => BlocProvider(
                create: (_) =>
                    DetailCubit(ctx.read<MoviesRepository>(), ctx.read<LocalStoreService>()),
                child: const DetailPage(),
              ),
              '/recent': (ctx) => BlocProvider(
                create: (_) => RecentCubit(ctx.read<LocalStoreService>())..load(),
                child: const RecentPage(),
              ),
            },
          );
        },
      ),
    ),
  );
}

--- di.dart:END ---

--- main.dart:START ---
import 'package:flutter/widgets.dart';
import 'package:movie_searcher/di.dart';

void main() {
  WidgetsFlutterBinding.ensureInitialized();
  runApp(buildApp());
}

--- main.dart:END ---

--- data\models\movie_dto.dart:START ---
class MovieDto {
  final String imdbId;
  final String title;
  final String year;
  final String poster;
  final String genre;
  final String plot;

  MovieDto({
    required this.imdbId,
    required this.title,
    required this.year,
    required this.poster,
    required this.genre,
    required this.plot,
  });

  factory MovieDto.fromJson(Map<String, dynamic> j) => MovieDto(
    imdbId: (j['imdbID'] ?? '') as String,
    title: (j['Title'] ?? '') as String,
    year: (j['Year'] ?? '') as String,
    poster: (j['Poster'] ?? '') as String,
    genre: (j['Genre'] ?? '') as String,
    plot: (j['Plot'] ?? '') as String,
  );

  Map<String, dynamic> toJson() => {
    'title': title,
    'year': year,
    'imdbId': imdbId,
    'poster': poster,
    'genre': genre,
    'plot': plot,
  };
}

--- data\models\movie_dto.dart:END ---

--- data\models\user_dto.dart:START ---

--- data\models\user_dto.dart:END ---

--- data\repositories\movies_repository.dart:START ---
import 'package:movie_searcher/data/models/movie_dto.dart';
import 'package:movie_searcher/data/services/movie_service.dart';
import 'package:movie_searcher/domain/models/movie.dart';

class MoviesRepository {
  final MovieService service;
  MoviesRepository(this.service);

  Future<List<Movie>> search(String query) async {
    final List<MovieDto> dtos = await service.fetchMovies(query);
    return dtos
        .map((d) => Movie(id: d.imdbId, title: d.title, year: d.year, poster: d.poster))
        .toList();
  }

  Future<Movie> getById(String imdbId) async {
    final d = await service.fetchMovieById(imdbId);
    return Movie(
      id: d.imdbId,
      title: d.title,
      year: d.year,
      poster: d.poster,
      genre: d.genre,
      plot: d.plot,
    );
  }
}

--- data\repositories\movies_repository.dart:END ---

--- data\repositories\user_repository.dart:START ---

--- data\repositories\user_repository.dart:END ---

--- data\services\dio_service.dart:START ---
import 'package:dio/dio.dart';

class DioService {
  final Dio dio;
  DioService(String baseUrl)
    : dio = Dio(BaseOptions(baseUrl: baseUrl, connectTimeout: const Duration(seconds: 10), receiveTimeout: const Duration(seconds: 15)));
}

--- data\services\dio_service.dart:END ---

--- data\services\local_store_service.dart:START ---
import 'package:shared_preferences/shared_preferences.dart';

class LocalStoreService {
  static const _key = 'recent_movies';
  Future<void> saveRecent(String row) async {
    if (row.trim().isEmpty) return;

    final prefs = await SharedPreferences.getInstance();
    final raw = prefs.getStringList(_key) ?? [];
    final id = row.split('|').first;
    final dedup = [row, ...raw.where((e) => !e.startsWith('$id|'))];
    await prefs.setStringList(_key, dedup.take(5).toList());
  }

  Future<List<String>> getRecents() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getStringList(_key) ?? [];
  }

  Future<void> clearAll() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.remove(_key);
  }
}

--- data\services\local_store_service.dart:END ---

--- data\services\movie_service.dart:START ---
import 'package:dio/dio.dart';
import '../models/movie_dto.dart';
import 'dio_service.dart';

class MovieService {
  final Dio _dio;
  final String apiKey;
  MovieService(DioService dioService, {required this.apiKey}) : _dio = dioService.dio;

  Future<List<MovieDto>> fetchMovies(String query) async {
    final res = await _dio.get(
      '',
      queryParameters: {'apikey': apiKey, 's': query, 'type': 'movie'},
    );
    final list = (res.data['Search'] as List?) ?? [];
    return list.map((e) => MovieDto.fromJson(e as Map<String, dynamic>)).toList();
  }

  Future<MovieDto> fetchMovieById(String id) async {
    final res = await _dio.get('', queryParameters: {'apikey': apiKey, 'i': id, 'plot': 'full'});
    return MovieDto.fromJson(res.data as Map<String, dynamic>);
  }
}

--- data\services\movie_service.dart:END ---

--- domain\models\movie.dart:START ---
class Movie {
  final String id;
  final String title;
  final String year;
  final String poster;
  final String genre;
  final String plot;

  const Movie({
    required this.id,
    required this.title,
    required this.year,
    required this.poster,
    this.genre = '',
    this.plot = '',
  });
}

--- domain\models\movie.dart:END ---

--- ui\core\layout\breakpoints_rules.dart:START ---
import 'package:flutter/widgets.dart';

enum Breakpoint { xs, sm, md, lg, xl }

Breakpoint breakpointForWidth(double w) {
  if (w < 450) return Breakpoint.xs;
  if (w < 740) return Breakpoint.sm;
  if (w < 1200) return Breakpoint.md;
  if (w < 1600) return Breakpoint.lg;
  return Breakpoint.xl;
}

extension BreakpointX on BuildContext {
  Breakpoint get layoutBreakPoint => breakpointForWidth(MediaQuery.sizeOf(this).width);
}

int movieGridColumns(Breakpoint bp) {
  switch (bp) {
    case Breakpoint.xs:
      return 1;
    case Breakpoint.sm:
      return 2;
    case Breakpoint.md:
      return 3;
    case Breakpoint.lg:
      return 4;
    case Breakpoint.xl:
      return 6;
  }
}

--- ui\core\layout\breakpoints_rules.dart:END ---

--- ui\core\theme\app_theme.dart:START ---
import 'package:flutter/material.dart';
import 'package:movie_searcher/ui/core/theme/palette.dart';
import 'package:movie_searcher/ui/core/theme/typography.dart';

ThemeData buildLightTheme() {
  final base = ThemeData(
    useMaterial3: true,
    colorSchemeSeed: seedColor,
    brightness: Brightness.light,
    visualDensity: VisualDensity.adaptivePlatformDensity,
  );

  return base.copyWith(
    textTheme: buildTextTheme(base.textTheme),
    scaffoldBackgroundColor: base.colorScheme.surface,
    appBarTheme: AppBarTheme(
      centerTitle: false,
      elevation: 0,
      backgroundColor: base.colorScheme.surface,
      foregroundColor: base.colorScheme.onSurface,
    ),
    cardTheme: CardThemeData(
      elevation: 1,
      margin: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      clipBehavior: Clip.antiAlias,
    ),
    inputDecorationTheme: InputDecorationTheme(
      filled: true,
      // Se der erro com surfaceContainerHighest, troque por surfaceVariant
      fillColor: base.colorScheme.surfaceContainerHighest,
      border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
      enabledBorder: OutlineInputBorder(
        borderSide: BorderSide(color: base.colorScheme.outlineVariant),
        borderRadius: BorderRadius.circular(12),
      ),
      focusedBorder: OutlineInputBorder(
        borderSide: BorderSide(color: base.colorScheme.primary),
        borderRadius: BorderRadius.circular(12),
      ),
      labelStyle: TextStyle(color: base.colorScheme.onSurfaceVariant),
    ),
    elevatedButtonTheme: ElevatedButtonThemeData(
      style: ElevatedButton.styleFrom(
        minimumSize: const Size(48, 48),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      ),
    ),
    filledButtonTheme: FilledButtonThemeData(
      style: FilledButton.styleFrom(
        minimumSize: const Size(48, 48),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      ),
    ),
    navigationBarTheme: NavigationBarThemeData(
      indicatorColor: base.colorScheme.secondaryContainer,
      backgroundColor: base.colorScheme.surface,
      elevation: 1,
    ),
    dividerTheme: DividerThemeData(color: base.colorScheme.outlineVariant),
  );
}

ThemeData buildDarkTheme() {
  final base = ThemeData(
    useMaterial3: true,
    colorSchemeSeed: seedColor,
    brightness: Brightness.dark,
    visualDensity: VisualDensity.adaptivePlatformDensity,
  );

  return base.copyWith(
    textTheme: buildTextTheme(base.textTheme),
    cardTheme: CardThemeData(
      elevation: 1,
      margin: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      clipBehavior: Clip.antiAlias,
      // Se der erro com surfaceContainer, troque por surfaceVariant
      color: base.colorScheme.surfaceContainer,
    ),
    inputDecorationTheme: InputDecorationTheme(
      filled: true,
      fillColor: base.colorScheme.surfaceContainerHighest,
      border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
      enabledBorder: OutlineInputBorder(
        borderSide: BorderSide(color: base.colorScheme.outlineVariant),
        borderRadius: BorderRadius.circular(12),
      ),
      focusedBorder: OutlineInputBorder(
        borderSide: BorderSide(color: base.colorScheme.primary),
        borderRadius: BorderRadius.circular(12),
      ),
      labelStyle: TextStyle(color: base.colorScheme.onSurfaceVariant),
    ),
  );
}

--- ui\core\theme\app_theme.dart:END ---

--- ui\core\theme\palette.dart:START ---
import 'package:flutter/material.dart';

const seedColor = Colors.teal; // cor base (M3)

--- ui\core\theme\palette.dart:END ---

--- ui\core\theme\theme_cubit.dart:START ---
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:shared_preferences/shared_preferences.dart';

class ThemeCubit extends Cubit<ThemeMode> {
  static const _key = 'theme_mode';
  ThemeCubit() : super(ThemeMode.system);

  Future<void> load() async {
    final prefs = await SharedPreferences.getInstance();
    final raw = prefs.getString(_key) ?? 'system';
    switch (raw) {
      case 'light':
        emit(ThemeMode.light);
        break;
      case 'dark':
        emit(ThemeMode.dark);
        break;
      default:
        emit(ThemeMode.system);
    }
  }

  Future<void> toggle() async {
    final next = switch (state) {
      ThemeMode.light => ThemeMode.dark,
      ThemeMode.dark => ThemeMode.system,
      ThemeMode.system => ThemeMode.light,
    };
    emit(next);
    final prefs = await SharedPreferences.getInstance();
    final s = switch (next) {
      ThemeMode.light => 'light',
      ThemeMode.dark => 'dark',
      ThemeMode.system => 'system',
    };
    await prefs.setString(_key, s);
  }
}

--- ui\core\theme\theme_cubit.dart:END ---

--- ui\core\theme\typography.dart:START ---
import 'package:flutter/material.dart';

TextTheme buildTextTheme(TextTheme base) => base.copyWith(
  headlineSmall: base.headlineSmall?.copyWith(fontWeight: FontWeight.w700),
  titleLarge: base.titleLarge?.copyWith(fontWeight: FontWeight.w700),
  bodyLarge: base.bodyLarge?.copyWith(height: 1.3),
  bodyMedium: base.bodyMedium?.copyWith(height: 1.3),
);

--- ui\core\theme\typography.dart:END ---

--- ui\core\widgets\theme_toggle_action.dart:START ---
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:movie_searcher/ui/core/theme/theme_cubit.dart';

class ThemeToggleAction extends StatelessWidget {
  const ThemeToggleAction({super.key});

  @override
  Widget build(BuildContext context) {
    final mode = context.watch<ThemeCubit>().state;
    final icon = switch (mode) {
      ThemeMode.light => Icons.light_mode,
      ThemeMode.dark => Icons.dark_mode,
      ThemeMode.system => Icons.brightness_auto,
    };
    final tooltip =
        'Tema: ${switch (mode) {
          ThemeMode.light => 'Claro',
          ThemeMode.dark => 'Escuro',
          ThemeMode.system => 'Automático',
        }} (toque p/ alternar)';

    return IconButton(
      tooltip: tooltip,
      icon: Icon(icon),
      onPressed: () => context.read<ThemeCubit>().toggle(),
    );
  }
}

--- ui\core\widgets\theme_toggle_action.dart:END ---

--- ui\movies\views\detail_page.dart:START ---
// ui/movies/views/detail_page.dart
import 'dart:math' as math;
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:movie_searcher/ui/movies/view_models/detail/detail_cubit.dart';
import 'package:movie_searcher/ui/movies/view_models/detail/detail_state.dart';

class DetailPage extends StatefulWidget {
  const DetailPage({super.key});
  @override
  State<DetailPage> createState() => _DetailPageState();
}

class _DetailPageState extends State<DetailPage> {
  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    final id = ModalRoute.of(context)!.settings.arguments as String;
    context.read<DetailCubit>().load(id);
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Detalhes')),
      body: BlocBuilder<DetailCubit, DetailState>(
        builder: (_, state) {
          if (state is DetailLoading) {
            return const Center(child: CircularProgressIndicator());
          }
          if (state is DetailError) {
            return Center(child: Text('Erro: ${state.message}'));
          }

          final m = (state as DetailLoaded).movie;

          return LayoutBuilder(
            builder: (context, constraints) {
              final isCompact = constraints.maxWidth < 720;
              // Mantém o poster pequeno para não evidenciar pixelização
              final posterWidth = isCompact
                  ? math.min(constraints.maxWidth * 0.30, 120.0)
                  : 180.0; // no máx 180 em telas maiores

              final info = _MovieInfo(title: m.title, year: m.year, genre: m.genre, plot: m.plot);

              return SingleChildScrollView(
                padding: const EdgeInsets.all(16),
                child: isCompact
                    // Mobile: poster pequeno à esquerda, infos à direita; plot abaixo
                    ? Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Row(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              _Poster(url: m.poster, width: posterWidth),
                              const SizedBox(width: 16),
                              Expanded(child: info.headerOnly()),
                            ],
                          ),
                          const SizedBox(height: 16),
                          info.plotOnly(),
                        ],
                      )
                    // Wide: duas colunas, poster fixo à esquerda e tudo à direita
                    : Row(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          _Poster(url: m.poster, width: posterWidth),
                          const SizedBox(width: 24),
                          Expanded(child: info.full()),
                        ],
                      ),
              );
            },
          );
        },
      ),
    );
  }
}

/// Pôster pequeno, 2:3, com bordas e `cacheWidth` para evitar upscale
/// Pôster pequeno, tamanho fixo (2:3), bordas e cacheWidth
class _Poster extends StatelessWidget {
  final String url;
  final double width;
  const _Poster({required this.url, required this.width});

  @override
  Widget build(BuildContext context) {
    final dpr = MediaQuery.of(context).devicePixelRatio;
    final cacheWidth = (width * dpr).round();
    final height = width * 1.5; // 2:3 -> altura = largura * 1.5

    return SizedBox(
      width: width,
      height: height,
      child: ClipRRect(
        borderRadius: BorderRadius.circular(12),
        child: Image.network(
          url,
          fit: BoxFit.cover,
          cacheWidth: cacheWidth,
          filterQuality: FilterQuality.medium,
          errorBuilder: (_, __, ___) => Container(
            color: Theme.of(context).colorScheme.surfaceContainerHighest,
            alignment: Alignment.center,
            child: const Icon(Icons.image_not_supported, size: 48),
          ),
          loadingBuilder: (context, child, progress) {
            if (progress == null) return child;
            return Center(
              child: CircularProgressIndicator(
                value: (progress.expectedTotalBytes != null)
                    ? progress.cumulativeBytesLoaded / progress.expectedTotalBytes!
                    : null,
              ),
            );
          },
        ),
      ),
    );
  }
}

/// Bloco com título/ano/gênero/plot em pedaços reutilizáveis (mobile e wide)
class _MovieInfo {
  final String title;
  final String year;
  final String genre;
  final String plot;
  _MovieInfo({required this.title, required this.year, required this.genre, required this.plot});

  Widget headerOnly() => Builder(
    builder: (context) => Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(title, style: Theme.of(context).textTheme.headlineSmall),
        const SizedBox(height: 4),
        Text(year, style: Theme.of(context).textTheme.bodyMedium),
        const SizedBox(height: 8),
        _GenreChips(genre: genre),
      ],
    ),
  );

  Widget plotOnly() => Builder(
    builder: (context) => Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Text(
          plot.isEmpty ? 'Sem sinopse disponível.' : plot,
          style: Theme.of(context).textTheme.bodyMedium,
        ),
      ),
    ),
  );

  Widget full() => Builder(
    builder: (context) => Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(title, style: Theme.of(context).textTheme.headlineSmall),
        const SizedBox(height: 4),
        Text(year, style: Theme.of(context).textTheme.bodyMedium),
        const SizedBox(height: 8),
        _GenreChips(genre: genre),
        const SizedBox(height: 16),
        plotOnly(),
      ],
    ),
  );
}

/// Converte "Action, Sci-Fi" em chips
class _GenreChips extends StatelessWidget {
  final String genre;
  const _GenreChips({required this.genre});

  @override
  Widget build(BuildContext context) {
    final parts = genre.split(',').map((e) => e.trim()).where((e) => e.isNotEmpty).toList();
    if (parts.isEmpty) return const SizedBox.shrink();
    return Wrap(
      spacing: 8,
      runSpacing: 8,
      children: [
        for (final g in parts)
          Chip(
            label: Text(g),
            visualDensity: VisualDensity.compact,
            materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
          ),
      ],
    );
  }
}

--- ui\movies\views\detail_page.dart:END ---

--- ui\movies\views\recent_page.dart:START ---
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:movie_searcher/ui/core/widgets/theme_toggle_action.dart';
import 'package:movie_searcher/ui/movies/view_models/recent/recent_cubit.dart';
import 'package:movie_searcher/ui/movies/view_models/recent/recent_state.dart';
import 'package:movie_searcher/ui/movies/widgets/movie_card.dart';
import 'package:movie_searcher/ui/movies/widgets/movie_grid_title.dart';

int _cols(double w) {
  if (w >= 1200) return 6;
  if (w >= 840) return 4;
  if (w >= 600) return 2;
  return 1;
}

class RecentPage extends StatefulWidget {
  const RecentPage({super.key});
  @override
  State<RecentPage> createState() => _RecentPageState();
}

class _RecentPageState extends State<RecentPage> {
  @override
  void initState() {
    super.initState();
    Future.microtask(() => context.read<RecentCubit>().load());
  }

  @override
  Widget build(BuildContext context) {
    final size = MediaQuery.of(context).size;
    final cols = _cols(size.width);

    return Scaffold(
      appBar: AppBar(title: const Text('Recentes'), actions: const [ThemeToggleAction()]),
      body: Padding(
        padding: const EdgeInsets.fromLTRB(16, 12, 16, 16),
        child: BlocBuilder<RecentCubit, RecentState>(
          builder: (_, state) {
            if (state is RecentLoading) {
              return const Center(child: CircularProgressIndicator());
            }
            if (state is RecentEmpty) {
              return const _Empty();
            }
            if (state is RecentError) {
              return Center(child: Text('Erro: ${state.message}'));
            }
            final items = (state as RecentLoaded).items;

            if (cols == 1) {
              return ListView.builder(
                itemCount: items.length,
                itemBuilder: (_, i) => MovieCard(movie: items[i]),
              );
            }
            return GridView.builder(
              gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
                crossAxisCount: cols,
                mainAxisSpacing: 12,
                crossAxisSpacing: 12,
                childAspectRatio: 2 / 3 + 0.15,
              ),
              itemCount: items.length,
              itemBuilder: (_, i) => MovieGridTile(movie: items[i]),
            );
          },
        ),
      ),
      floatingActionButton: FloatingActionButton.extended(
        onPressed: () => context.read<RecentCubit>().clear(),
        icon: const Icon(Icons.delete_sweep_outlined),
        label: const Text('Limpar'),
      ),
    );
  }
}

class _Empty extends StatelessWidget {
  const _Empty();

  @override
  Widget build(BuildContext context) {
    final cs = Theme.of(context).colorScheme;
    return Center(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(Icons.history, size: 56, color: cs.outline),
          const SizedBox(height: 12),
          const Text('Sem filmes recentes.'),
        ],
      ),
    );
  }
}

--- ui\movies\views\recent_page.dart:END ---

--- ui\movies\views\search_page.dart:START ---
// ui/movies/views/search_page.dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:movie_searcher/ui/core/layout/breakpoints_rules.dart';
import 'package:movie_searcher/ui/core/widgets/theme_toggle_action.dart';
import 'package:movie_searcher/ui/movies/view_models/search/search_bloc.dart';
import 'package:movie_searcher/ui/movies/view_models/search/search_event.dart';
import 'package:movie_searcher/ui/movies/widgets/search_page/result_sliver.dart';
import 'package:movie_searcher/ui/movies/widgets/search_page/search_bar/search_bar_area.dart';

class SearchPage extends StatefulWidget {
  const SearchPage({super.key});
  @override
  State<SearchPage> createState() => _SearchPageState();
}

class _SearchPageState extends State<SearchPage> {
  final searchTxtCtrl = TextEditingController();

  @override
  Widget build(BuildContext context) {
    final bloc = context.read<SearchBloc>();
    final cols = movieGridColumns(context.layoutBreakPoint);

    return Scaffold(
      appBar: AppBar(title: const Text('Movie Searcher'), actions: const [ThemeToggleAction()]),
      body: CustomScrollView(
        slivers: [
          SliverPadding(
            padding: const EdgeInsets.fromLTRB(16, 16, 16, 8),
            sliver: SliverToBoxAdapter(
              child: SearchBarArea(
                controller: searchTxtCtrl,
                onChanged: (t) => bloc.add(SearchTextChanged(t)),
                onSubmit: () => bloc.add(SearchSubmitted(searchTxtCtrl.text)),
                onRecentTap: () => Navigator.pushNamed(context, '/recent'),
              ),
            ),
          ),
          const SliverPadding(
            padding: EdgeInsets.fromLTRB(16, 8, 16, 16),
            sliver: SizedBox.shrink(),
          ),
          SliverPadding(
            padding: const EdgeInsets.fromLTRB(16, 0, 16, 16),
            sliver: ResultsSliver(columns: cols),
          ),
        ],
      ),
    );
  }
}

--- ui\movies\views\search_page.dart:END ---

--- ui\movies\view_models\detail\detail_cubit.dart:START ---
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:movie_searcher/data/repositories/movies_repository.dart';
import 'package:movie_searcher/data/services/local_store_service.dart';
import 'detail_state.dart';

class DetailCubit extends Cubit<DetailState> {
  final MoviesRepository repo;
  final LocalStoreService local;
  DetailCubit(this.repo, this.local) : super(const DetailLoading());

  Future<void> load(String id) async {
    emit(const DetailLoading());
    try {
      final m = await repo.getById(id);
      final row = '${m.id}|${m.title}|${m.year}|${m.poster}';
      await local.saveRecent(row);
      emit(DetailLoaded(m));
    } catch (e) {
      emit(DetailError(e.toString()));
    }
  }
}

--- ui\movies\view_models\detail\detail_cubit.dart:END ---

--- ui\movies\view_models\detail\detail_state.dart:START ---
import 'package:movie_searcher/domain/models/movie.dart';

sealed class DetailState {
  const DetailState();
}

class DetailLoading extends DetailState {
  const DetailLoading();
}

class DetailLoaded extends DetailState {
  final Movie movie;
  const DetailLoaded(this.movie);
}

class DetailError extends DetailState {
  final String message;
  const DetailError(this.message);
}

--- ui\movies\view_models\detail\detail_state.dart:END ---

--- ui\movies\view_models\recent\recent_cubit.dart:START ---
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:movie_searcher/data/services/local_store_service.dart';
import 'package:movie_searcher/domain/models/movie.dart';
import 'recent_state.dart';

class RecentCubit extends Cubit<RecentState> {
  final LocalStoreService local;
  RecentCubit(this.local) : super(const RecentLoading());

  Future<void> load() async {
    emit(const RecentLoading());
    try {
      final rows = await local.getRecents();

      final items = <Movie>[];
      for (final r in rows) {
        final p = r.split('|');
        if (p.length >= 4 && p[0].isNotEmpty) {
          items.add(Movie(id: p[0], title: p[1], year: p[2], poster: p[3]));
        }
      }

      if (items.isEmpty) {
        emit(const RecentEmpty());
      } else {
        emit(RecentLoaded(items));
      }
    } catch (e) {
      emit(RecentError(e.toString()));
    }
  }

  Future<void> clear() async {
    await local.clearAll();
    emit(const RecentEmpty());
  }
}

--- ui\movies\view_models\recent\recent_cubit.dart:END ---

--- ui\movies\view_models\recent\recent_state.dart:START ---
import 'package:movie_searcher/domain/models/movie.dart';

sealed class RecentState {
  const RecentState();
}

class RecentLoading extends RecentState {
  const RecentLoading();
}

class RecentLoaded extends RecentState {
  final List<Movie> items;
  const RecentLoaded(this.items);
}

class RecentEmpty extends RecentState {
  const RecentEmpty();
}

class RecentError extends RecentState {
  final String message;
  const RecentError(this.message);
}

--- ui\movies\view_models\recent\recent_state.dart:END ---

--- ui\movies\view_models\search\search_bloc.dart:START ---
// ui/movies/view_models/search/search_bloc.dart
import 'dart:async';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:movie_searcher/data/repositories/movies_repository.dart';
import 'search_event.dart';
import 'search_state.dart';

class SearchBloc extends Bloc<SearchEvent, SearchState> {
  final MoviesRepository moviesRepository;
  Timer? _debounce;
  bool _closing = false;

  SearchBloc(this.moviesRepository) : super(const SearchIdle()) {
    on<SearchTextChanged>(_onChanged);
    on<SearchSubmitted>(_onSubmitted);
    on<SearchCleared>((_, emit) => emit(const SearchIdle()));
  }

  void _onChanged(SearchTextChanged event, Emitter<SearchState> _) {
    if (_closing) return;

    _debounce?.cancel();
    final q = event.query;

    _debounce = Timer(const Duration(milliseconds: 400), () {
      if (_closing || isClosed) return;
      add(SearchSubmitted(q));
    });
  }

  Future<void> _onSubmitted(SearchSubmitted event, Emitter<SearchState> emit) async {
    final q = event.query.trim();
    if (q.isEmpty) {
      emit(const SearchIdle());
      return;
    }
    emit(const SearchLoading());
    try {
      final results = await moviesRepository.search(q);
      if (results.isEmpty) {
        emit(const SearchEmpty());
      } else {
        emit(SearchSuccess(results));
      }
    } catch (err) {
      emit(SearchError(err.toString()));
    }
  }

  @override
  Future<void> close() {
    _closing = true;
    _debounce?.cancel();
    _debounce = null;
    return super.close();
  }
}

--- ui\movies\view_models\search\search_bloc.dart:END ---

--- ui\movies\view_models\search\search_event.dart:START ---
abstract class SearchEvent {}

class SearchTextChanged extends SearchEvent {
  final String query;
  SearchTextChanged(this.query);
}

class SearchSubmitted extends SearchEvent {
  final String query;
  SearchSubmitted(this.query);
}

class SearchCleared extends SearchEvent {}

--- ui\movies\view_models\search\search_event.dart:END ---

--- ui\movies\view_models\search\search_state.dart:START ---
import 'package:movie_searcher/domain/models/movie.dart';

sealed class SearchState {
  const SearchState();
}

class SearchIdle extends SearchState {
  const SearchIdle();
}

class SearchLoading extends SearchState {
  const SearchLoading();
}

class SearchSuccess extends SearchState {
  final List<Movie> results;
  const SearchSuccess(this.results);
}

class SearchEmpty extends SearchState {
  const SearchEmpty();
}

class SearchError extends SearchState {
  final String message;
  const SearchError(this.message);
}

--- ui\movies\view_models\search\search_state.dart:END ---

--- ui\movies\widgets\movie_card.dart:START ---
import 'package:flutter/material.dart';
import 'package:movie_searcher/domain/models/movie.dart';

class MovieCard extends StatelessWidget {
  final Movie movie;
  const MovieCard({super.key, required this.movie});

  @override
  Widget build(BuildContext context) {
    final cs = Theme.of(context).colorScheme;

    return Card(
      child: InkWell(
        onTap: () => Navigator.pushNamed(context, '/detail', arguments: movie.id),
        child: Row(
          children: [
            Hero(
              tag: 'poster_${movie.id}',
              child: ClipRRect(
                borderRadius: const BorderRadius.only(
                  topLeft: Radius.circular(16),
                  bottomLeft: Radius.circular(16),
                ),
                child: Image.network(
                  movie.poster,
                  width: 96,
                  height: 128,
                  fit: BoxFit.cover,
                  errorBuilder: (_, __, ___) => Container(
                    width: 96,
                    height: 128,
                    color: cs.surfaceContainer,
                    child: const Icon(Icons.image_not_supported),
                  ),
                ),
              ),
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Padding(
                padding: const EdgeInsets.symmetric(vertical: 12),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      movie.title,
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                      style: Theme.of(context).textTheme.titleMedium,
                    ),
                    const SizedBox(height: 6),
                    Text(movie.year, style: Theme.of(context).textTheme.bodyMedium),
                  ],
                ),
              ),
            ),
            const SizedBox(width: 12),
          ],
        ),
      ),
    );
  }
}

--- ui\movies\widgets\movie_card.dart:END ---

--- ui\movies\widgets\movie_grid_title.dart:START ---
import 'package:flutter/material.dart';
import 'package:movie_searcher/domain/models/movie.dart';

class MovieGridTile extends StatelessWidget {
  final Movie movie;
  const MovieGridTile({super.key, required this.movie});

  @override
  Widget build(BuildContext context) {
    final cs = Theme.of(context).colorScheme;

    return Card(
      child: InkWell(
        onTap: () => Navigator.pushNamed(context, '/detail', arguments: movie.id),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            Expanded(
              child: Hero(
                tag: 'poster_${movie.id}',
                child: ClipRRect(
                  borderRadius: const BorderRadius.only(
                    topLeft: Radius.circular(16),
                    topRight: Radius.circular(16),
                  ),
                  child: AspectRatio(
                    aspectRatio: 2 / 3,
                    child: Image.network(
                      movie.poster,
                      fit: BoxFit.cover,
                      errorBuilder: (_, __, ___) => Container(
                        color: cs.surfaceContainer,
                        child: const Icon(Icons.image_not_supported, size: 48),
                      ),
                      loadingBuilder: (ctx, child, progress) {
                        if (progress == null) return child;
                        return Container(
                          color: cs.surfaceContainer,
                          alignment: Alignment.center,
                          child: const CircularProgressIndicator(strokeWidth: 2),
                        );
                      },
                    ),
                  ),
                ),
              ),
            ),
            Padding(
              padding: const EdgeInsets.fromLTRB(12, 10, 12, 12),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    movie.title,
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                    style: Theme.of(context).textTheme.titleMedium,
                  ),
                  const SizedBox(height: 4),
                  Text(movie.year, style: Theme.of(context).textTheme.bodySmall),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}

--- ui\movies\widgets\movie_grid_title.dart:END ---

--- ui\movies\widgets\search_page\result_sliver.dart:START ---
// ui/movies/widgets/search/results_sliver.dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:movie_searcher/ui/movies/view_models/search/search_bloc.dart'; // <— importe o bloc
import 'package:movie_searcher/ui/movies/view_models/search/search_state.dart';
import 'package:movie_searcher/ui/movies/widgets/movie_card.dart';
import 'package:movie_searcher/ui/movies/widgets/movie_grid_title.dart';
import 'package:movie_searcher/ui/movies/widgets/search_page/states_sliver.dart';

class ResultsSliver extends StatelessWidget {
  final int columns;
  const ResultsSliver({super.key, required this.columns});

  @override
  Widget build(BuildContext context) {
    return BlocBuilder<SearchBloc, SearchState>(
      builder: (context, state) {
        return switch (state) {
          SearchLoading() => const SliverFillRemaining(
            hasScrollBody: false,
            child: Center(child: CircularProgressIndicator()),
          ),
          SearchEmpty() => const EmptyStateSliver(
            icon: Icons.search_off,
            message: 'Nenhum resultado.',
          ),
          SearchError(message: final m) => ErrorStateSliver(message: m),
          SearchSuccess(results: final list) =>
            columns == 1
                ? SliverList.builder(
                    itemCount: list.length,
                    itemBuilder: (_, i) => MovieCard(movie: list[i]),
                  )
                : SliverGrid.builder(
                    gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
                      crossAxisCount: columns,
                      mainAxisSpacing: 12,
                      crossAxisSpacing: 12,
                      childAspectRatio: 2 / 3 + 0.15,
                    ),
                    itemCount: list.length,
                    itemBuilder: (_, i) => MovieGridTile(movie: list[i]),
                  ),
          SearchIdle() => const EmptyStateSliver(
            icon: Icons.local_movies_outlined,
            message: 'Busque um filme pelo título.',
          ),
        };
      },
    );
  }
}

--- ui\movies\widgets\search_page\result_sliver.dart:END ---

--- ui\movies\widgets\search_page\states_sliver.dart:START ---
// ui/movies/widgets/search/states_slivers.dart
import 'package:flutter/material.dart';

class EmptyStateSliver extends StatelessWidget {
  final IconData icon;
  final String message;
  const EmptyStateSliver({super.key, required this.icon, required this.message});

  @override
  Widget build(BuildContext context) {
    final cs = Theme.of(context).colorScheme;
    return SliverFillRemaining(
      hasScrollBody: false,
      child: Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(icon, size: 56, color: cs.outline),
            const SizedBox(height: 12),
            Text(message, textAlign: TextAlign.center),
          ],
        ),
      ),
    );
  }
}

class ErrorStateSliver extends StatelessWidget {
  final String message;
  const ErrorStateSliver({super.key, required this.message});

  @override
  Widget build(BuildContext context) {
    final cs = Theme.of(context).colorScheme;
    return SliverFillRemaining(
      hasScrollBody: false,
      child: Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(Icons.error_outline, size: 56, color: cs.error),
            const SizedBox(height: 12),
            Text('Erro: $message', textAlign: TextAlign.center),
          ],
        ),
      ),
    );
  }
}

--- ui\movies\widgets\search_page\states_sliver.dart:END ---

--- ui\movies\widgets\search_page\search_bar\search_bar_area.dart:START ---
// ui/movies/widgets/search/search_bar_area.dart
import 'package:flutter/material.dart';
import 'package:movie_searcher/ui/core/layout/breakpoints_rules.dart';

enum SearchBarLayout { compact, tightRow, comfortableRow }

class SearchBarArea extends StatelessWidget {
  final TextEditingController controller;
  final ValueChanged<String> onChanged;
  final VoidCallback onSubmit;
  final VoidCallback onRecentTap;

  const SearchBarArea({
    super.key,
    required this.controller,
    required this.onChanged,
    required this.onSubmit,
    required this.onRecentTap,
  });

  searchBarLayoutForWidth(Breakpoint bp) {
    if (bp == Breakpoint.xs) {
      return SearchBarLayout.compact;
    } else if (bp == Breakpoint.sm || bp == Breakpoint.md) {
      return SearchBarLayout.tightRow;
    } else {
      return SearchBarLayout.comfortableRow;
    }
  }

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, c) {
        final layout = searchBarLayoutForWidth(context.layoutBreakPoint);
        return switch (layout) {
          SearchBarLayout.compact => _CompactLayout(
            controller: controller,
            onChanged: onChanged,
            onSubmit: onSubmit,
            onRecentTap: onRecentTap,
          ),
          SearchBarLayout.tightRow => _TightRowLayout(
            controller: controller,
            onChanged: onChanged,
            onSubmit: onSubmit,
            onRecentTap: onRecentTap,
          ),
          SearchBarLayout.comfortableRow => _ComfortableRowLayout(
            controller: controller,
            onChanged: onChanged,
            onSubmit: onSubmit,
            onRecentTap: onRecentTap,
          ),
        };
      },
    );
  }
}

/// ---------- peças reutilizáveis ----------
class _SearchField extends StatelessWidget {
  final TextEditingController controller;
  final ValueChanged<String> onChanged;
  final VoidCallback onSubmit;
  const _SearchField({required this.controller, required this.onChanged, required this.onSubmit});

  @override
  Widget build(BuildContext context) {
    final cs = Theme.of(context).colorScheme;
    return ValueListenableBuilder<TextEditingValue>(
      valueListenable: controller,
      builder: (_, v, __) {
        final hasText = v.text.isNotEmpty;
        return TextField(
          controller: controller,
          textInputAction: TextInputAction.search,
          decoration: InputDecoration(
            hintText: 'Buscar por título',
            prefixIcon: Icon(Icons.search, color: cs.onSurfaceVariant),
            suffixIcon: hasText
                ? IconButton(
                    tooltip: 'Limpar',
                    icon: const Icon(Icons.clear),
                    onPressed: () {
                      controller.clear();
                      onChanged('');
                    },
                  )
                : null,
          ),
          onChanged: onChanged,
          onSubmitted: (_) {
            FocusScope.of(context).unfocus();
            onSubmit();
          },
          maxLines: 1,
        );
      },
    );
  }
}

/// ---------- layouts ----------
class _CompactLayout extends StatelessWidget {
  final TextEditingController controller;
  final ValueChanged<String> onChanged;
  final VoidCallback onSubmit;
  final VoidCallback onRecentTap;
  const _CompactLayout({
    required this.controller,
    required this.onChanged,
    required this.onSubmit,
    required this.onRecentTap,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(12),
        child: Column(
          children: [
            _SearchField(controller: controller, onChanged: onChanged, onSubmit: onSubmit),
            const SizedBox(height: 12),
            Row(
              children: [
                Expanded(
                  child: SizedBox(
                    height: 48,
                    child: FilledButton.icon(
                      onPressed: () {
                        FocusScope.of(context).unfocus();
                        onSubmit();
                      },
                      icon: const Icon(Icons.search),
                      label: const Text('Buscar'),
                    ),
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: SizedBox(
                    height: 48,
                    child: OutlinedButton.icon(
                      onPressed: onRecentTap,
                      icon: const Icon(Icons.history),
                      label: const Text('Recentes'),
                    ),
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}

class _TightRowLayout extends StatelessWidget {
  final TextEditingController controller;
  final ValueChanged<String> onChanged;
  final VoidCallback onSubmit;
  final VoidCallback onRecentTap;
  const _TightRowLayout({
    required this.controller,
    required this.onChanged,
    required this.onSubmit,
    required this.onRecentTap,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(12),
        child: Row(
          children: [
            Expanded(
              child: _SearchField(controller: controller, onChanged: onChanged, onSubmit: onSubmit),
            ),
            const SizedBox(width: 8),
            SizedBox(
              height: 48,
              width: 48,
              child: IconButton.filled(
                tooltip: 'Buscar',
                onPressed: () {
                  FocusScope.of(context).unfocus();
                  onSubmit();
                },
                icon: const Icon(Icons.search),
              ),
            ),
            const SizedBox(width: 4),
            SizedBox(
              height: 48,
              width: 48,
              child: IconButton(
                tooltip: 'Recentes',
                onPressed: onRecentTap,
                icon: const Icon(Icons.history),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class _ComfortableRowLayout extends StatelessWidget {
  final TextEditingController controller;
  final ValueChanged<String> onChanged;
  final VoidCallback onSubmit;
  final VoidCallback onRecentTap;
  const _ComfortableRowLayout({
    required this.controller,
    required this.onChanged,
    required this.onSubmit,
    required this.onRecentTap,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(12),
        child: Row(
          children: [
            Expanded(
              child: _SearchField(controller: controller, onChanged: onChanged, onSubmit: onSubmit),
            ),
            const SizedBox(width: 12),
            SizedBox(
              height: 48,
              child: FilledButton.icon(
                onPressed: () {
                  FocusScope.of(context).unfocus();
                  onSubmit();
                },
                icon: const Icon(Icons.search),
                label: const Text('Buscar'),
              ),
            ),
            const SizedBox(width: 8),
            IconButton(
              tooltip: 'Recentes',
              onPressed: onRecentTap,
              icon: const Icon(Icons.history),
            ),
          ],
        ),
      ),
    );
  }
}

--- ui\movies\widgets\search_page\search_bar\search_bar_area.dart:END ---
